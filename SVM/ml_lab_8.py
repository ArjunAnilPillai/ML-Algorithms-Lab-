# -*- coding: utf-8 -*-
"""ML Lab 8

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11ePFuMW86B5pJxCEZmLyByCox4RZC2xg

#Name - Arjun A.
#Roll number - 181CO109
#Date of submission - 12-3-2021
This notebook was written in google colab. <br>Link to view notebook<br>
https://colab.research.google.com/drive/11ePFuMW86B5pJxCEZmLyByCox4RZC2xg?usp=sharing

#ML Lab 8 - SVM algorithms
This notebook is used to implement the SVM or Support Vector Machine Algorithms to classify a handwritten digits dataset.

##Importing necessary packages
"""

from sklearn.svm import SVC
from sklearn.model_selection import train_test_split 
from sklearn.datasets import load_digits 
from sklearn.metrics import confusion_matrix, classification_report
import numpy as np 
import matplotlib.pyplot as plt
import pandas as pd

"""## Importing the images dataset and splitting the dataset
It is taken from the test set of https://archive.ics.uci.edu/ml/datasets/Optical+Recognition+of+Handwritten+Digits<br>
Size of the image - 8 x 8 <br>
The dataset has been split 70:30 into train and test datasets. 
"""

def loadDataset():
  digits = load_digits()
    
  #Flattening image
  print('Shape of np array before flattening -', np.shape(digits.images))
  n_samples = len(digits.images)
  data = digits.images.reshape((n_samples, -1))
  print('Shape of np array after flattening -', np.shape(data))
  print()

  #Printing a few examples
  _, axes = plt.subplots(nrows=1, ncols=4, figsize=(10, 3))
  for ax, image, label in zip(axes, digits.images, digits.target):
    ax.set_axis_off()
    ax.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
    ax.set_title('Training: %i' % label)

  #Splitting the dataset
  X_train, X_test, y_train, y_test = train_test_split(data, digits.target, test_size = 0.7, random_state = 100, shuffle = False) #Specifying random_state to get the same dataset split everytime 

  #Returning 
  return data, digits.target, X_train, X_test, y_train, y_test

X, Y, X_train, X_test, y_train, y_test = loadDataset()

#Original flattened dataset shape
print('X shape -', np.shape(X))
print('Y shape -', np.shape(Y))
print()

#Printing size of the split
print('Test dataset size\nX_test -', len(X_test), '\ny_test -', len(y_test), '\n')
print('Train dataset size\nX_train -', len(X_train), '\ny_train -', len(y_train))
print()

"""## Defining model(s)"""

linearSVM = SVC(kernel = 'linear')
polySVM = SVC(kernel = 'poly')
rbfSVM = SVC(kernel = 'rbf')
sigSVM = SVC(kernel = 'sigmoid')

"""##Training all models on the train dataset"""

linearSVM.fit(X_train, y_train)
polySVM.fit(X_train, y_train)
rbfSVM.fit(X_train, y_train)
sigSVM.fit(X_train, y_train)

"""## Using the model to classify images in the test dataset"""

linearPred = linearSVM.predict(X_test)
polyPred = polySVM.predict(X_test)
rbfPred = rbfSVM.predict(X_test)
sigPred = sigSVM.predict(X_test)

"""## Function for class-wise accuracy to compare between different SVMs"""

def accuracyClassWise(cm):
  #Now the normalize the diagonal entries
  cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]

  #The diagonal entries are the accuracies of each class
  return list(cm.diagonal())

"""##Finding accuracy for all models using the test dataset

### Linear SVM
"""

print('Report for Linear SVM\n')
print(classification_report(y_test, linearPred))
print('\n Confusion matrix')
print(confusion_matrix(y_test, linearPred))
linearCA = accuracyClassWise(confusion_matrix(y_test, linearPred))

"""### Polynomial SVM"""

print('Report for Polynomial SVM\n')
print(classification_report(y_test, polyPred))
print('\n Confusion matrix')
print(confusion_matrix(y_test, polyPred))

polyCA = accuracyClassWise(confusion_matrix(y_test, polyPred))

"""### RBF(Radial Basis Function) SVM"""

print('Report for RBF SVM\n')
print(classification_report(y_test, rbfPred))
print('\n Confusion matrix')
print(confusion_matrix(y_test, rbfPred))

rbfCA = accuracyClassWise(confusion_matrix(y_test, rbfPred))

"""### Sigmoid SVM"""

print('Report for Sigmoid SVM\n')
print(classification_report(y_test, sigPred))
print('\n Confusion matrix')
print(confusion_matrix(y_test, sigPred))

sigCA = accuracyClassWise(confusion_matrix(y_test, sigPred))

"""### Comparing class-wise accuracies of the different SVMs

"""

fig = plt.figure()
ax = plt.axes()
plt.plot([0,1,2,3,4,5,6,7,8,9], linearCA, label = 'Linear')
plt.plot([0,1,2,3,4,5,6,7,8,9], polyCA, label = 'Polynomial')
plt.plot([0,1,2,3,4,5,6,7,8,9], rbfCA, label = 'RBF')
plt.plot([0,1,2,3,4,5,6,7,8,9], sigCA, label = 'Sigmoid')
plt.xlabel('Number(0-9)')
plt.ylabel('Accuracy(digit-wise)')
plt.title('Accuracy vs Number')
plt.legend()
plt.savefig('181CO109 SVM accuracy graph.pdf')
plt.show()