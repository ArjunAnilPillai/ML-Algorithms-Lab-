# -*- coding: utf-8 -*-
"""ML Lab 6 - Multilinear Regression

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1flPQKQyznxEp5kBDmfE15rUoFH70Tfr4

#Name - Arjun A.
#Roll number - 181CO109
#Date of submission - 26-02-2021
This notebook was written in google colab. <br>Link to view notebook<br>
https://colab.research.google.com/drive/1flPQKQyznxEp5kBDmfE15rUoFH70Tfr4?usp=sharing

#Machine Learning Lab 6
This notebook is used to implement Multilinear regression using sci-kit learn on the boston dataset with 13 features

##Importing necessary packages
"""

from sklearn.model_selection import train_test_split
from sklearn import linear_model
import numpy as np 
import pandas as pd
import matplotlib.pyplot as plt 
from sklearn import datasets

"""##Loading the dataset using sci-kit
Loading and assigning the dataset using sci-kit learn 
"""

data = datasets.load_boston()
df = pd.DataFrame(data.data, columns=data.feature_names)
target = pd.DataFrame(data.target, columns=['MEDV'])
featNames = data.feature_names

X = df
Y = target

"""##Splitting the data into train and test sets
 Splitting the data in the ratio of 7:3. (70% training and 30% testing)
"""

def splitdataset(X, Y): 

  X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.3, random_state = 100) #Specifying random_state to get the same dataset split everytime 
	
  return X, Y, X_train, X_test, y_train, y_test

X, Y, X_train, X_test, y_train, y_test = splitdataset(X, Y)

#Use to print the entire dataset
#print(X, Y, X_train, X_test, y_train, y_test, sep = '\n\n')

#Printing size of the split
print('Test dataset size\nX_test -', len(X_test), '\ny_test -', len(y_test), '\n')
print('Train dataset size\nX_train -', len(X_train), '\ny_train -', len(y_train))

"""##Training the model
Using sci-kit, training the model to obtain a hyperplane.
"""

lm = linear_model.LinearRegression()
model = lm.fit(X_train,y_train)

"""##The equation of the hyperplane
Printing the equation of the hyperplane. 
"""

coeff = list(zip(lm.coef_[0], featNames))
intercept = list(lm.intercept_)
print('MEDV(i.e Y) =', intercept[0], end = ' ')
for i in coeff:
  print('+', '({} * {})'.format(i[0], i[1]), end = ' ')

"""##Printing accuracy related measures
Test error on the test data is to be computed. 
"""

#Function for finding accuracy 
def measuringAccuracy(y, yp):
  y = y.to_numpy()
  countEntries = np.count_nonzero(y > 0, axis = 0)[0]
  ymean = np.sum(y, axis = 0)[0]/countEntries
  sumnormal, sumsq, sumrelnormal, sumrelsq = 0, 0, 0, 0
  for i in range(countEntries):
    sumnormal += abs(yp[i][0] - y[i][0])
    sumsq += (yp[i][0] - y[i][0]) ** 2
    sumrelnormal += abs(y[i][0] - ymean)
    sumrelsq += (y[i][0] - ymean) ** 2

  mae = round((sumnormal/countEntries), 4)
  mse = round((sumsq/countEntries), 4)
  rae = round((sumnormal/sumrelnormal), 4)
  rse = round((sumsq/sumrelsq), 4)
  rmse = round(((sumsq/countEntries)**0.5), 4)
  rrse = round(((sumsq/sumrelsq)**0.5), 4)

  print('Mean Absoulte Error =', mae)
  print('Mean Squared Error =', mse)
  print('Relative Absoulte Error =', rae)
  print('Relative Squared Error =', rse)
  print('Root Mean Squared Error = ', rmse)
  print('Root Relative Squared Error = ', rrse)

y_predict = lm.predict(X_test)
measuringAccuracy(y_test, y_predict)

print("R-squared score is:",lm.score(X_test,y_test))